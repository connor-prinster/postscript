%!

% important global
/inch {
	72 mul
} def

% ------------------------------------------%
% ------------------------------------------%
%            ---- Triforce ----            %
% ------------------------------------------%
% ------------------------------------------%
/maxDepth 10 def
/origLen 400 def
/origX 60 def
/origY 300 def
 % as height will be the height of an equilateral triangle, it will be
 % the long side of a 30-60-90 triangle, or sqrt3
/sqrt3 1.7320508 def

/tri {
    newpath % start a new path
    x y moveto
    len 0 rlineto % move 'a' to the left by length (base)
    120 rotate % rotate to draw the right side
    len 0 rlineto % draw this side
    240 rotate % rotate so we complete a circle (360 deg)
    closepath % end the path by returning to the beginning
    stroke % draw the path we have set
} def

/recTri {
    % will be sent as x, y, len, depth (but stack is wack)
    /depth exch def 
    /len exch def
    /y exch def
    /x exch def

    tri % draw the triangle with the new values
    depth maxDepth lt { % if we haven't done too much 'recursion'
        /newDepth 1 depth add def % newdepth = depth + 1
        /newLen len 2 div def % we cut the length in half for the new bases of the triforce

        % ---
        % draw three new triangles
        % ---

        % bottom left
        x 
        y
        newLen 
        newDepth 

        % top triangle
        x len 4 div add % x + newLen/4
        y sqrt3 len mul 4 div add % y + newLen * (sqrt3/4) (len instead of newLen for height of original triangle)
        newLen 
        newDepth

        % bottom right
        x newLen add % x + newLen
        y 
        newLen 
        newDepth % bottom right

        % run all three in their own recursion
        recTri recTri recTri
    } if
} def

0 setlinewidth
% (x, y, length, origDepth = 0) to recTri the first time
origX origY origLen 0 recTri

% showpage
grestore

%-------------------------------------------%
%-------------------------------------------%
%            ---- Box Curve ----            %
%-------------------------------------------%
%-------------------------------------------%
% variables : X Y
% constants : F + −
% start : FX
% rules : 
%   X = X+YF+
%   Y = −FX−Y
% angle : 90°

/boxSides { % each 'box' will have 3 sides
    3
} def

/size { % max size of the box
    10
} def

/angle {
    90
} def

/Xbox { % X+YF+
    dup 0 ne { % comparing the size to 0 (as size is on top)
        1 sub % subtract 1 from size
        boxSides {dup} repeat Xbox + Ybox F +
    } if
    pop 
} def

/Ybox { % −FX−Y
    dup 0 ne { % comparing the size to 0 (as size is on top)
        1 sub % subtract 1 from size
        boxSides {dup} repeat - F Xbox - Ybox
    } if
    pop 
} def

/F {
    % 0 eq { 10 0 rlineto } if 
    10 0 rlineto 
} def

/+ { % turn right 90
    angle rotate
} def

/- { % turn left 90
    angle neg rotate
} def

1 inch 2.5 inch translate
% 0 setlinewidth
newpath
50 0 moveto
90 rotate
2000 Xbox
stroke
grestore

%--------------------------------------------------------%
%--------------------------------------------------------%
%            ---- Connor's Pointy Spiral ----            %
%--------------------------------------------------------%
%--------------------------------------------------------%
% variables : X Y
% constants : F + −
% start : X
% rules : 
%   X = -FX++FY-
%   Y = +FX--FY+
% angle : 80°

/Xps { % X+YF+
    dup 0 ne {
        1 sub 4 {dup} repeat -ps Fps Xps +ps +ps Fps Yps -ps
    } if 
    pop
} def

/Yps { % −FX−Y
    dup 0 ne {
        1 sub 4 {dup} repeat +ps Fps Xps -ps -ps Fps Yps +ps
    } if 
    pop
} def

/Fps {
    20 0 rlineto
} bind def

/+ps { 
    80 rotate 
} bind def

/-ps { 
    80 neg rotate 
} bind def

newpath
400 180 moveto
90 rotate
500 Xps
stroke
grestore
showpage

